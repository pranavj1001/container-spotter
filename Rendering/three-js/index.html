<html>
	<head>
		<title>Container Spotter Example</title>
		<link rel="stylesheet" href="css/bootstrap.min.css">
		<link rel="stylesheet" href="css/style.css">
		<!-- <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous"> -->
		<style>
			
		</style>
	</head>
	<body>

		<!-- <div id="hideController" class="toggle-controller">X</div> -->
		<div class="row">
				<div id="controller" class="col-md-3 container-spotter-no-padding-div container">
					<div class="container-spotter-content-div">
						<h3>Container Spotter</h3>

						<h4>Bin Dimensions</h5>
						<div class="form-group">
							<div class="row">
								<div class="col-lg-4 container-spotter-input-label-block">
									<label for="binXCoordinate">Length</label>
									<input type="number" class="form-control" name="binXCoordinate" id="binXCoordinate">
								</div>
								<div class="col-lg-4 container-spotter-input-label-block">
									<label for="binYCoordinate">Width</label>
									<input type="number" class="form-control" name="binYCoordinate" id="binYCoordinate">
								</div>
								<div class="col-lg-4 container-spotter-input-label-block">
									<label for="binZCoordinate">Height</label>
									<input type="number" class="form-control" name="binZCoordinate" id="binZCoordinate">
								</div>
							</div>
						</div>
						<h4>Item Dimensions</h4>

						<hr>
						<button class="btn btn-primary" onclick="renderItems()">Pack</button>
					</div>
				</div>
		
				<div id="view" class="col-md-9 container-spotter-no-padding-div"></div>
		</div>

		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/spotterLogic.js"></script>
		<script>
			var scene = new THREE.Scene();
			scene.background = new THREE.Color(0x808080);
			var renderer = new THREE.WebGLRenderer();
			var viewContainer = document.getElementById('view');
			renderer.setSize( viewContainer.offsetWidth, viewContainer.offsetHeight );
			viewContainer.appendChild( renderer.domElement );
			var camera = new THREE.PerspectiveCamera( 75, viewContainer.offsetWidth/viewContainer.offsetHeight, 0.1, 1000 );

			let containerGeometryX = 20;
			let containerGeometryY = 10;
			let containerGeometryZ = 10;

			var containerGeometry = new THREE.BoxGeometry( containerGeometryX, containerGeometryY, containerGeometryZ );
			var containerMaterial = [];
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.7,
				color:0x111122,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			var containerEdges = new THREE.EdgesGeometry( containerGeometry );
			var containerLine = new THREE.LineSegments( containerEdges, new THREE.LineBasicMaterial( { color: 0x111111 } ) );
			var containerCube = new THREE.Mesh( containerGeometry, containerMaterial );

			//create a Object3D and add the two cubes
			var binObject = new THREE.Object3D();
			binObject.add(containerCube);
			binObject.add(containerLine);

			scene.add(binObject);

			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();

			// directional light
			var light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 1, 1, 1 );
			scene.add( light );

			// ambient light
			var ambient = new THREE.AmbientLight( 0xffffff );
			scene.add( ambient );
			
			camera.position.set(0,0,30);
			renderer.render( scene, camera );

			var controls = new THREE.OrbitControls( camera, viewContainer );
			controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
			controls.dampingFactor = 0.05;
			controls.screenSpacePanning = false;
			controls.minDistance = 20;
			controls.maxDistance = 40;
			controls.maxPolarAngle = Math.PI / 2;

			animate();

			window.addEventListener( 'resize', onWindowResize, false );
			// document.getElementById('controller').addEventListener( 'click', handleClickEvents, false );
			document.getElementById('controller').addEventListener( 'mousedown', handleClickEvents, false );
			// document.getElementById('controller').addEventListener( 'mouseup', handleClickEvents, false );
			viewContainer.addEventListener( 'mousemove', onMouseMove, false );
			var focusedElement;
			function handleClickEvents(event) {
				var element = event.target || event.srcElement
				if (element !== renderer.domElement) {
					event.stopPropagation();
					event.preventDefault();
					if (element.tagName === 'INPUT') {
						element.focus();
					} else {
						document.activeElement.blur();
					}
				}
			}

			function onWindowResize() {
				camera.aspect = viewContainer.offsetWidth / viewContainer.offsetHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( viewContainer.offsetWidth, viewContainer.offsetHeight );
			}

			function onMouseMove( event ) {

				// calculate mouse position in normalized device coordinates
				// (-1 to +1) for both components

				mouse.x = ( ( event.clientX - viewContainer.offsetLeft ) / viewContainer.clientWidth ) * 2 - 1;
				mouse.y = - ( ( event.clientY - viewContainer.offsetTop ) / viewContainer.clientHeight ) * 2 + 1;

			}
			var INTERSECTED;

			function animate() {
				requestAnimationFrame( animate );
				controls.update();

				// update the picking ray with the camera and mouse position
				raycaster.setFromCamera( mouse, camera );

				// calculate objects intersecting the picking ray
				var intersects = raycaster.intersectObjects( scene.children[0].children.slice(2) );

				// for ( var i = 0; i < intersects.length; i++ ) {
				// 	intersects[ i ].object.material.color.set( 0xff0000 );
				// }

				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xffffff );
					}
				} else {
					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					INTERSECTED = null;
				}

				renderer.render( scene, camera );
			};

			var cubes = [];
			function renderItems() {

				containerGeometry.dispose();
				containerEdges.dispose();

				containerGeometryX = parseFloat(document.getElementById('binXCoordinate').value) || 20;
				containerGeometryY = parseFloat(document.getElementById('binYCoordinate').value) || 10;
				containerGeometryZ = parseFloat(document.getElementById('binZCoordinate').value) || 10;

				var newContainerGeometry = new THREE.BoxGeometry( containerGeometryX, containerGeometryY, containerGeometryZ );
				var newContainerEdges = new THREE.EdgesGeometry( newContainerGeometry );
				containerCube.geometry = newContainerGeometry;
				containerLine.geometry = newContainerEdges;

				bin = {
					length: containerGeometryX,
					breadth: containerGeometryY,
					height: containerGeometryZ
				};

				// if items are atleast packed once
				// then remove packed items form binObject
				if (cubes.length > 0) {
					for (const cube of cubes) {
						var counter = 0;
						for (const item of binObject.children) {
							if (cube.uuid === item.uuid) {
								binObject.children.splice(counter, 1);
								break;
							}
							counter++;
						}
					}
					cubes = [];
					packedItems = [];
					pivots = [{
						xCoordinate: 0,
						yCoordinate: 0,
						zCoordinate: 0,
						origin: true
					}];
				}

				packItems();
				// render boxes as per spotting logic
				for (const item of packedItems) {
					const itemGeometry = new THREE.BoxGeometry( item.length, item.breadth, item.height );
					// boxType1Geometry.translate(
						// boxType1GeometryX/2 - containerGeometryX/2, 
						// boxType1GeometryY/2 - containerGeometryY/2,  
						// boxType1GeometryZ/2 - containerGeometryZ/2, 
					// );
					itemGeometry.translate(
						(item.length - containerGeometryX) / 2,
						(item.breadth - containerGeometryY) / 2,
						(item.height - containerGeometryZ) / 2
					);
					const itemMaterial = new THREE.MeshLambertMaterial( { color: item.color } );
					const itemCube = new THREE.Mesh( itemGeometry, itemMaterial );
					const itemPivot = item.pivotPosition;
					itemCube.position.set(itemPivot.xCoordinate, itemPivot.yCoordinate, itemPivot.zCoordinate);
					binObject.add(itemCube);
					cubes.push(itemCube);
				}

			}
		</script>
	</body>
</html>