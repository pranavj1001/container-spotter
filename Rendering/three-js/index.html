<html>
	<head>
		<title>Container Spotter Example</title>
		<link rel="stylesheet" href="css/bootstrap.min.css">
		<link rel="stylesheet" href="css/style.css">
		<!-- <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous"> -->
		<style>
			
		</style>
	</head>
	<body>

		<div id="hideController" class="toggle-controller">X</div>
		<div class="row">
				<div id="controller" class="col-md-3">

				</div>
		
				<div id="view" class="col-md-9"></div>
		</div>

		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/spotterLogic.js"></script>
		<script>
			var scene = new THREE.Scene();
			scene.background = new THREE.Color(0x808080);
			var renderer = new THREE.WebGLRenderer();
			var viewContainer = document.getElementById('view');
			renderer.setSize( viewContainer.offsetWidth, viewContainer.offsetHeight );
			viewContainer.appendChild( renderer.domElement );
			var camera = new THREE.PerspectiveCamera( 75, viewContainer.offsetWidth/viewContainer.offsetHeight, 0.1, 1000 );

			const containerGeometryX = 20;
			const containerGeometryY = 10;
			const containerGeometryZ = 10;

			var containerGeometry = new THREE.BoxGeometry( containerGeometryX, containerGeometryY, containerGeometryZ );
			var containerMaterial = [];
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.7,
				color:0x111122,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			containerMaterial.push(new THREE.MeshLambertMaterial({
				opacity:0.1,
				transparent: true,
				side: THREE.DoubleSide
			}));
			var containerEdges = new THREE.EdgesGeometry( containerGeometry );
			var containerLine = new THREE.LineSegments( containerEdges, new THREE.LineBasicMaterial( { color: 0x111111 } ) );
			var containerCube = new THREE.Mesh( containerGeometry, containerMaterial );

			//create a Object3D and add the two cubes
			var binObject = new THREE.Object3D();
			binObject.add(containerCube);
			binObject.add(containerLine);

			// render boxes as per spotting logic
			for (const item of packedItems) {
				const itemGeometry = new THREE.BoxGeometry( item.length, item.breadth, item.height );
				// boxType1Geometry.translate(
					// boxType1GeometryX/2 - containerGeometryX/2, 
					// boxType1GeometryY/2 - containerGeometryY/2,  
					// boxType1GeometryZ/2 - containerGeometryZ/2, 
				// );
				itemGeometry.translate(
					(item.length - containerGeometryX) / 2,
					(item.breadth - containerGeometryY) / 2,
					(item.height - containerGeometryZ) / 2
				);
				const itemMaterial = new THREE.MeshLambertMaterial( { color: item.color } );
				const itemCube = new THREE.Mesh( itemGeometry, itemMaterial );
				const itemPivot = item.pivotPosition;
				itemCube.position.set(itemPivot.xCoordinate, itemPivot.yCoordinate, itemPivot.zCoordinate);
				binObject.add(itemCube);
			}

			scene.add(binObject);

			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();

			// directional light
			var light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 1, 1, 1 );
			scene.add( light );

			// ambient light
			var ambient = new THREE.AmbientLight( 0xffffff );
			scene.add( ambient );
			
			camera.position.set(0,0,30);

			var controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
			controls.dampingFactor = 0.05;
			controls.screenSpacePanning = false;
			controls.minDistance = 20;
			controls.maxDistance = 40;
			controls.maxPolarAngle = Math.PI / 2;

			renderer.render( scene, camera );
			animate();

			window.addEventListener( 'resize', onWindowResize, false );
			viewContainer.addEventListener( 'mousemove', onMouseMove, false );
			// onWindowResize();
			function onWindowResize() {
				camera.aspect = viewContainer.offsetWidth / viewContainer.offsetHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( viewContainer.offsetWidth, viewContainer.offsetHeight );
			}

			function onMouseMove( event ) {

				// calculate mouse position in normalized device coordinates
				// (-1 to +1) for both components

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}
			var INTERSECTED;

			function animate() {
				requestAnimationFrame( animate );
				controls.update();

				// update the picking ray with the camera and mouse position
				raycaster.setFromCamera( mouse, camera );

				// calculate objects intersecting the picking ray
				var intersects = raycaster.intersectObjects( scene.children[0].children.slice(2) );

				// for ( var i = 0; i < intersects.length; i++ ) {
				// 	intersects[ i ].object.material.color.set( 0xff0000 );
				// }

				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xffffff );
					}
				} else {
					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					INTERSECTED = null;
				}

				renderer.render( scene, camera );
			};
		</script>
	</body>
</html>